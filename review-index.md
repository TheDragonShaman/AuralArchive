# AuralArchive File Review Index

Single dashboard for the production-readiness sweep. Track each area with Status, Header coverage, and action notes.

## Review Expectations
- Every file must include the standardized header block.
- Research each file before refactoring to preserve intent.
- Remove unused imports and dead code along the way.
- Clean up logging statements for consistency.
- Remove any comments or text that implies AI authorship.
- Function-level comments are allowed when they explain behavior from the dev team’s perspective.
- Ask questions before making assumptions or major changes.
- Work one file at a time (including helper modules); verify the result before proceeding to the next file.
- For each reviewed file, document current performance bottlenecks and the upgrades needed to improve them so we can revisit after cleanup.

## Entry Points
- [x] **app.py**
	- [x] Insert standard header block.
	- [x] Remove/replace AI-related comments.
	- [x] Reformat imports + blueprint registration notes.
- [x] **wsgi.py**
	- [x] Insert standard header block.
	- [x] Match environment setup with `app.py`.
	- [x] Verify gunicorn/flask entry docstring.

## Core Back-End
- [ ] **routes/**
	- [x] main.py (dashboard + stats APIs).
		- Performance follow-up: `/api/library/stats` loads every book row on each request just to count authors/hours; replace with aggregate SQL or cached metrics to avoid full-table scans.
		- Performance follow-up: `_get_download_snapshot` logs into qBittorrent and fetches the full torrent list on every page render; run a periodic snapshot worker and serve cached results to keep the dashboard light.
	- [x] library.py + related templates.
		- Performance follow-up: `library_page` pulls the entire catalog and formats every book before pagination, which will time out once the library grows—switch to paginated DB queries and lazy client rendering.
		- Performance follow-up: stats (hours/ownership counts) are recomputed in Python on each request; move them into scheduled rollups or SQL aggregates.
	- [x] downloads / download_progress_api.
		- [x] download_progress_api blueprint cleanup.
		- Performance follow-up: `downloads_page` runs multiple blocking `get_queue` calls per request; expose a single batched endpoint or WebSocket feed so the UI isn't waiting on redundant queue scans.
		- Performance follow-up: download progress polling still walks the full queue and filters client-side; add filtered/paginated queue APIs so large queues don't swamp the route.
	- [ ] series + discover + auxiliary routes.
		- [x] search.py (renamed from catalog_browser_routes; header + dead code cleanup).
			- Performance follow-up: the search views call Audible + local services sequentially on the request thread; queue searches/enhancements asynchronously and return cached results to keep latency predictable.
			- Performance follow-up: library status checks hit the database per ASIN; batch lookup statuses or preload a map so searches don't trigger dozens of round-trips.
		- [x] authors.py (header + import cleanup).
			- Performance follow-up: author dashboards rebuild stats by iterating every title and calling hybrid/audnexus services inline; precompute author analytics and cache catalog pulls per author.
			- Performance follow-up: import helpers loop through full catalogs to filter languages each request; push filtering into the data service and paginate to avoid multi-thousand item payloads.
		- [x] discover.py (header refresh).
			- Performance follow-up: `/discover` loads all books + authors to compute counters every time; add summary tables or caching so we aren't recomputing totals on each refresh.
			- Performance follow-up: recommendation service availability is checked synchronously; stash the last-known status and refresh in the background instead of adding network latency to the page load.
		- [x] imports.py (renamed from import_page; header refresh).
			- Performance follow-up: the route hits ConfigService on every request just to read a few defaults; memoize the config snapshot and invalidate when settings change.
		- [x] settings.py + settings_tools/* helpers (headers/import cleanup).
			- Performance follow-up: many AJAX handlers execute long-running tasks (client tests, cache clears, backups) synchronously; route these through a job queue and stream progress back over websockets.
			- Performance follow-up: the settings landing page gathers data from half a dozen services sequentially; prefetch via background tasks or parallelize service calls to reduce load times.
			- Performance follow-up (settings_tools): helpers like `backup_database`, `optimize_database`, and `restart_services` still block the request until completion; convert them into idempotent task triggers with progress polling endpoints.
		- [x] series.py (header + logging cleanup).
			- Performance follow-up: most endpoints call `db_service.series.sync_library_status()` on every request, forcing expensive scans; move the sync into a scheduled job and let the route read cached status.
			- Performance follow-up: `/api/<series_asin>/books` re-fetches and recomputes statistics each call; cache per-series summaries and expose invalidation hooks when metadata changes.
		- [x] Removed unused test_progress_api blueprint.
		- [x] Removed legacy audible_library/discover_clean/settings_module_clean/streaming_download_api files.
- [ ] **api/**
	- [x] manual_download_api + streaming.
		- [x] manual_download_api.py (header + module logger).
			- Performance follow-up: manual search + interactive search block the Flask worker while iterating indexers sequentially; move searches/quality scoring into a dedicated async worker and parallelize indexer calls to cut multi-second latency.
			- Performance follow-up: event loop setup happens per request (see `/manual/search`); reuse a shared loop or queue jobs into the search service to avoid repeated loop creation.
		- [x] streaming_download_api.py (verified existing header/logging).
			- Performance follow-up: `/api/stream-download/status` pulls the entire queue then filters in Python; expose a queue method that streams only Audible jobs or supports pagination to keep memory/latency predictable as the queue grows.
	- [x] audible_auth + audible_library APIs.
		- [x] audible_auth_api.py (header/import cleanup).
			- Performance follow-up: the login + OTP flow runs synchronously inside the request, so each audible.Authenticator call ties up a worker for several remote HTTP round-trips; push the heavy auth handshake/account fetch into a background task and poll for completion.
			- Performance follow-up: `_pending_auth_sessions` stays in-memory and never expires, which will bloat the dict under repeated OTP attempts; add TTL cleanup or persist sessions in Redis to avoid linear scans.
		- [x] audible_library_api.py (header/import cleanup).
			- Performance follow-up: `/download/all` invokes `library_service.download_all_books` inline; switch to a job queue so the HTTP request returns immediately and large downloads do not block Gunicorn workers.
			- Performance follow-up: metadata sync routes spin up a new thread + service per call; replace with a single long-lived sync worker (or task queue) so repeated sync requests reuse connections and we can meter concurrency.
	- [ ] download_management + settings APIs.
		- [x] audiobook_settings_api.py (header/import cleanup).
			- Performance follow-up: every endpoint repeatedly instantiates the config service and hits disk to read/write the same JSON, so introduce a short-lived cache or inject the service once per request cycle.
			- Performance follow-up: `get_audiobook_config` returns the entire config plus validation results each time; add pagination/section filters or serve cached snapshots so the UI isn’t moving multi-meg payloads on every refresh.
			- Performance follow-up: validation/reload/status routes run potentially long operations synchronously; convert them to queued tasks and expose polling endpoints so we don’t block Gunicorn workers during heavy config checks.
		- [x] conversion_settings_api.py (legacy placeholder header cleanup).
			- Performance follow-up: module still imports and raises on load; remove leftover blueprint registrations so the file isn’t touched during runtime, or delete the module entirely once callers are updated.
			- Performance follow-up: if we keep the placeholder, replace the module-level `RuntimeError` with a lightweight Flask 410 blueprint so accidental requests get fast responses without crashing the app during import.
		- [x] download_management_api.py (header/import cleanup).
			- Performance follow-up: `/queue` and `/statistics` still fetch full job payloads synchronously; push pagination/aggregation into the data layer and stream updates over websockets so refreshes don’t walk the whole queue.
			- Performance follow-up: pause/resume/retry endpoints directly call client RPCs on the Flask worker; move those state changes into the download service event loop and respond immediately while the worker handles the RPC.
			- Performance follow-up: status polling hits `get_download_management_service()` (and the underlying monitors) each request; cache the latest status snapshot and serve it with short-lived TTL to avoid hammering qBittorrent when the dashboard auto-refreshes.
		- [x] settings_api.py (header/import cleanup).
			- Performance follow-up: `/overview` gathers every book/author record to compute totals on each refresh; shift to cached aggregates or SQL COUNTs so the endpoint doesn’t scan the full DB.
			- Performance follow-up: log streaming re-opens and scans the log file per request; convert to a long-lived SSE/websocket tailer or leverage `watchdog` so clients receive incremental chunks without constant disk seeks.
			- Performance follow-up: diagnostics endpoints synchronously call psutil, config services, and metadata refresh routines in a single request; split them into targeted APIs or background jobs so the settings UI isn’t blocked by slow system calls.
		- [x] status_api.py (header/import cleanup).
			- Performance follow-up: `/feed` always queries the status service synchronously; add caching or incremental polling so multiple UI widgets don’t hit the service simultaneously.
			- Performance follow-up: module currently returns all event payload data; support `since` cursors or SSE so clients can stream incremental events instead of re-fetching the whole list.
		- [x] system_validation_api.py (header/import cleanup).
			- Performance follow-up: validation + integration test routes spin up new event loops per request; move test execution into a background worker and stream results to avoid blocking Flask threads.
			- Performance follow-up: `/api/system/status` and `/services/status` fetch and massage every service instance on each call; cache status snapshots or add diff-based polling to avoid repeatedly instantiating heavy service objects.
	- [x] download_progress_api.py (logger namespace cleanup).
		- Performance follow-up: each polling call spins up `get_audible_manager()` and walks the in-memory progress store; introduce a lightweight caching layer or expose updates over websockets so high-frequency polling doesn’t hammer the manager.
		- Performance follow-up: the bulk endpoint returns the entire progress dict in one shot; support incremental cursors or per-download lookups to keep payloads small.
	- [x] event_monitoring_api.py (header/import cleanup + dead code removal).
		- Performance follow-up: blueprint still mounts even though every handler returns “system removed”; replace with a 410/gone response or drop the module so the router doesn’t waste cycles on unused endpoints.
		- Performance follow-up: if monitoring ever returns, add server-side caching and SSE streaming so we aren’t recomputing stats for each request.
	- [x] health_monitoring_api.py (header/import cleanup).
		- Performance follow-up: every endpoint creates a brand new asyncio loop to hit the monitor; move health checks into a long-lived worker and expose cached snapshots.
		- Performance follow-up: the API reaches into private attributes (`_checkers`, `_monitoring`); wrap those in service methods so we don’t lock ourselves to the internal implementation.
	- [x] import_api.py (header refresh).
		- Performance follow-up: batch previews and imports run entirely in-request, meaning large imports tie up workers; offload heavy preview/import jobs to a background queue and stream state to the UI.
		- Performance follow-up: the batch cache lives in-process and relies on periodic access to expire; migrate to redis/sqlite with TTL so restarts don’t wipe active work.
	- [x] search_api.py (header/import cleanup).
		- Performance follow-up: search calls block the Flask worker for the entire indexer cycle; queue searches or shard work to async tasks so the API returns immediately.
		- Performance follow-up: health/test routes hit config + status services inline and build large payloads; memoize the diagnostics and only recompute on demand.
	- [x] search_api_backup.py (legacy header/import cleanup).
		- Performance follow-up: redundant legacy blueprint duplicates `/api/search` routes; remove or rename to avoid double registration, or wrap responses with HTTP 410 to signal deprecation quickly.
		- Performance follow-up: services referenced here are no longer wired; delete the module once all callers migrate to the new search stack to prevent accidental imports.
- [ ] **services/**
	- [ ] download_management package (queue, monitor, clients).
	- [ ] search_engine + indexers.
	- [ ] import_service + metadata helpers.
	- [x] __init__.py (header + package docstring).
		- Performance follow-up: importing heavy submodules at package import time forces Audible/config/database code to run even when unused; consider lazy-import proxies or an `__all__` that avoids touching optional services until requested.
		- Performance follow-up: the package currently re-exports bare classes but not factory helpers; migrate callers to the centralized `ServiceManager` so we are not instantiating duplicate service objects via direct imports.
	- [x] service_manager.py (header/import cleanup + logger sharing).
		- Performance follow-up: each getter instantiates heavyweight services synchronously on the request thread, so the first call to downloads/imports can block a Gunicorn worker for seconds; add a startup bootstrap or async task queue so long-lived clients come online outside the request lifecycle.
		- Performance follow-up: `get_service_status` only reports whether an object exists in `_services`, not whether the backing worker/connection is healthy; wire in per-service health probes + cached readiness data so the status endpoints don't give false positives.
	- [x] status_service.py (header/import cleanup + logger instrumentation).
		- Performance follow-up: the in-memory feed relies on a single global lock for enqueue/update operations; add sharded feeds or lock-free queues so high-volume event spikes (imports + downloads) do not serialize all callers.
		- Performance follow-up: events expire silently and are not persisted, so dashboard refreshes after a restart lose historical context; stream updates into redis or sqlite with TTL so the UI can replay longer timelines without overloading Flask memory.
	- [x] series_sync_service.py (header/import cleanup + centralized logger).
		- Performance follow-up: bulk sync walks every library title and fires synchronous Audible API calls sequentially, which will exceed rate limits on big libraries; move series sync into a queued worker with batching/backoff so Flask threads stay free and retries are tracked.
		- Performance follow-up: `sync_book_series` refetches the full series payload for each book even when the same series was synced moments earlier; persist recently synced series metadata or store Audible etags so repeated calls reuse cached payloads instead of hammering the API and database.

## Shared Utilities
- [ ] **utils/**
	- [ ] logger + error handler.
	- [ ] normalization utilities.
	- [ ] misc helpers (file/path utilities, etc.).
- [ ] **config/**
	- [ ] `config.py` (
configuration class).
	- [ ] `.env`/reference data docs.
	- [ ] composer/env sample files.
- [ ] **scripts/**
	- [ ] debug tools (e.g., `debug_myanonamouse.py`).
	- [ ] backfill/migration scripts.
	- [ ] automation helpers.

## Front-End Assets
- [ ] **templates/**
	- [ ] base.html + partials.
	- [ ] library, series, downloads views.
	- [ ] settings/discover/import pages.
- [ ] **static/**
	- [ ] JavaScript modules (library.js, series.js, etc.).
	- [ ] CSS/theme files (ensure no AI references).
	- [ ] Cached assets cleanup if needed.

## Quality & Docs
- [ ] **tests/**
	- [ ] unit tests under `tests/` root.
	- [ ] integration scripts.
	- [ ] data fixtures.
- [ ] **readme/**
	- [ ] root README + roadmap docs.
	- [ ] feature readmes under `readme/` folder.
	- [ ] inline code blocks follow header/comment policy.
